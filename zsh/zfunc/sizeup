sizeup () {
    # Show help message
    show_help() {
        cat << EOF
Usage: sizeup [--sum] [--explain] <path>
Display the logical size and size on disk of a file or directory. When
--sum is provided, also report the logical size by summing individual files.

Options:
    -h, --help    Show this help message
    --sum         Include a logical size calculated by summing file sizes
                  (can be slow for large trees)
    --explain     Print diagnostics explaining differences in measurements
                  (implies --sum because the explanation needs per-file data)

Measures explained:
    • Logical size: what the filesystem reports for the folder’s contents.
    • Size on disk: physical blocks allocated (rounded to 512-byte blocks).
    • Logical size (sum of files): direct sum of regular file sizes.
    • Unique file bytes (dedup): logical size minus duplicate hard links.

On macOS the on-disk figure is rounded up to 512-byte allocation blocks, so
small files may appear larger on disk than their logical size, and directories
may include metadata overhead. Compression, sparse files, or other filesystem
optimizations can also make the size on disk smaller than the logical size.

When using --explain, any remaining “Unreadable / other” bytes usually come
from content the script cannot stat directly (e.g., protected directories,
extended attributes, or resource forks that du -sA counts in the apparent
size). Those paths are listed when detected so you can investigate further.

Examples:
    sizeup /path/to/file
    sizeup /path/to/directory
    sizeup --sum /path/to/directory
EOF
    }

    if [[ $# -eq 0 ]]; then
        show_help
        return 1
    fi

    local sum_flag=0
    local explain_flag=0
    local target_path=""
    local humanize_available=0
    local -r DU_BLOCK_SIZE=512

    if command -v humanize_bytes >/dev/null 2>&1; then
        humanize_available=1
    fi

    if (( ! humanize_available )); then
        local maybe_dir=${${(%):-%N}:h}
        local humanize_path="$maybe_dir/humanize_bytes"
        if [[ -f "$humanize_path" ]]; then
            autoload -Uz humanize_bytes 2>/dev/null || source "$humanize_path" 2>/dev/null
            if command -v humanize_bytes >/dev/null 2>&1; then
                humanize_available=1
            fi
        fi
    fi

    local use_color=0
    local color_reset=""
    local color_pos=""
    local color_neg=""
    local color_neutral=""
    if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
        local tput_colors
        tput_colors=$(tput colors 2>/dev/null || printf '0')
        if (( tput_colors >= 8 )); then
            use_color=1
            color_reset=$'\e[0m'
            color_pos=$'\e[32m'
            color_neg=$'\e[31m'
            color_neutral=$'\e[36m'
        fi
    fi

    format_size_line() {
        local label="$1"
        local bytes="$2"
        if [[ -z "$bytes" ]]; then
            bytes=0
        fi

        local human=$(format_bytes "$bytes")
        printf "%-28s %s (%s)\n" "${label}:" "$human" "$bytes"
    }

    colorize() {
        local text="$1"
        local color="$2"
        if (( use_color )) && [[ -n "$color" ]]; then
            printf "%s%s%s" "$color" "$text" "$color_reset"
        else
            printf "%s" "$text"
        fi
    }

    format_bytes() {
        local value="$1"
        local human=""
        if (( humanize_available )); then
            human=$(humanize_bytes "$value" 2>/dev/null)
        fi
        if [[ -z "$human" ]]; then
            human="${value}B"
        fi
        printf "%s" "$human"
    }

    repeat_char() {
        local char="$1"
        local count="$2"
        if (( count <= 0 )); then
            return
        fi
        printf "%${count}s" "" | tr ' ' "$char"
    }

    format_cell() {
        local value="${1:-0}"
        local color="$color_neutral"
        local text=""
        if (( value == 0 )); then
            text="0B (0)"
        else
            local abs=${value#-}
            local human=$(format_bytes "$abs")
            [[ -z "$human" ]] && human="${abs}B"
            local sign="+"
            color=$color_pos
            if (( value < 0 )); then
                sign="-"
                color=$color_neg
            fi
            text="${sign}${human} (${value})"
        fi
        printf "%s\t%s" "$text" "$color"
    }

    stat_value_or_zero() {
        local format="$1"
        local path="$2"
        /usr/bin/stat -f "$format" "$path" 2>/dev/null || printf '0\n'
    }

    file_logical_bytes() {
        stat_value_or_zero '%z' "$1"
    }

    file_disk_bytes() {
        local blocks
        blocks=$(stat_value_or_zero '%b' "$1")
        printf '%s\n' "$(( blocks * DU_BLOCK_SIZE ))"
    }

    disk_bytes_for_path() {
        local path="$1"

        if [[ -f "$path" || -L "$path" ]]; then
            file_disk_bytes "$path"
            return
        fi

        local blocks
        blocks=$(/usr/bin/du -s "$path" 2>/dev/null | /usr/bin/awk '{print $1}')

        if [[ -n "$blocks" ]]; then
            printf '%s\n' "$(( blocks * DU_BLOCK_SIZE ))"
        else
            printf '0\n'
        fi
    }

    logical_bytes_for_path() {
        local path="$1"

        if [[ -f "$path" || -L "$path" ]]; then
            file_logical_bytes "$path"
            return
        fi

        local blocks
        blocks=$(/usr/bin/du -s -A "$path" 2>/dev/null | /usr/bin/awk '{print $1}')

        if [[ -n "$blocks" ]]; then
            printf '%s\n' "$(( blocks * DU_BLOCK_SIZE ))"
        else
            printf '0\n'
        fi
    }

    sum_bytes_for_path() {
        local path="$1"
        local bytes=""

        if [[ -f "$path" || -L "$path" ]]; then
            file_logical_bytes "$path"
            return
        fi

        bytes=$(/usr/bin/find "$path" -type f -print0 2>/dev/null | \
            while IFS= read -r -d '' file; do
                /usr/bin/stat -f '%z' "$file" 2>/dev/null || printf '0\n'
            done | /usr/bin/awk '{total+=$1} END {print total+0}')

        printf '%s\n' "${bytes:-0}"
    }

    dedup_bytes_for_path() {
        local path="$1"

        if [[ -f "$path" || -L "$path" ]]; then
            file_logical_bytes "$path"
            return
        fi

        /usr/bin/find "$path" -type f -print0 2>/dev/null | \
            while IFS= read -r -d '' file; do
                /usr/bin/stat -f '%i %z' "$file" 2>/dev/null || printf '0 0\n'
            done | /usr/bin/awk '{if(!seen[$1]++) sum+=$2} END {print sum+0}'
    }

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                return 0
                ;;
            --sum)
                sum_flag=1
                shift
                ;;
            --explain)
                explain_flag=1
                if (( ! sum_flag )); then
                    sum_flag=1
                fi
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "Error: unknown option '$1'"
                return 1
                ;;
            *)
                target_path="$1"
                shift
                break
                ;;
        esac
    done

    if [[ -z "$target_path" ]] && [[ $# -gt 0 ]]; then
        target_path="$1"
        shift
    fi

    if [[ -z "$target_path" ]]; then
        echo "Error: missing path argument"
        return 1
    fi

    if [[ $# -gt 0 ]]; then
        echo "Error: unexpected argument '$1'"
        return 1
    fi

    # Check if the path exists
    if [[ ! -e "$target_path" ]]; then
        echo "Error: '$target_path' does not exist"
        return 1
    fi

    # Prepare sum placeholders
    local sum_bytes=""
    local sum_dedup_bytes=""

    # Get size on disk (actual allocated space, rounded to 512-byte blocks)
    local disk_bytes
    disk_bytes=$(disk_bytes_for_path "$target_path")
    format_size_line "Size on disk" "$disk_bytes"

    # Get logical size (apparent size of data)
    local logical_bytes
    logical_bytes=$(logical_bytes_for_path "$target_path")
    format_size_line "Logical size" "$logical_bytes"

    if (( sum_flag )); then
        sum_bytes=$(sum_bytes_for_path "$target_path")
        format_size_line "Logical size (sum of files)" "$sum_bytes"

        sum_dedup_bytes=$(dedup_bytes_for_path "$target_path")
        if [[ -n "$sum_dedup_bytes" && "$sum_dedup_bytes" != "$sum_bytes" ]]; then
            format_size_line "Unique file bytes (dedup)" "$sum_dedup_bytes"
        fi
    fi

    if (( explain_flag )); then
        echo
        echo "Explain Differences"
        # Baselines (re-use logical_bytes to avoid conversion drift)
        local du_app_bytes="$logical_bytes"
        local stat_sum_nodedup=""
        local stat_sum_dedup=""
        if [[ -n "$sum_bytes" ]]; then
            stat_sum_nodedup="$sum_bytes"
        elif [[ -d "$target_path" ]]; then
            stat_sum_nodedup=$(sum_bytes_for_path "$target_path")
        else
            stat_sum_nodedup=$(file_logical_bytes "$target_path")
        fi

        if [[ -n "$sum_dedup_bytes" ]]; then
            stat_sum_dedup="$sum_dedup_bytes"
        elif [[ -d "$target_path" ]]; then
            stat_sum_dedup=$(dedup_bytes_for_path "$target_path")
        else
            stat_sum_dedup=$(file_logical_bytes "$target_path")
        fi

        local dir_bytes=0
        local dir_rounding_bytes=0
        local dir_alloc_bytes=0
        local file_rounding_bytes=0
        local file_round_alloc_bytes=0
        local special_total=0
        local special_alloc_bytes=0

        local -a skipped_paths=()

        local script_source=""
        if (( ${#funcsourcetrace[@]} > 0 )); then
            script_source=${funcsourcetrace[1]%:*}
        fi
        local sizeup_dir=${script_source:h}
        [[ -z "$sizeup_dir" || ! -d "$sizeup_dir" ]] && sizeup_dir=$(pwd)
        local helper_path="$sizeup_dir/_sizeup_scan.py"

        if [[ -d "$target_path" ]] && command -v python3 >/dev/null 2>&1 && [[ -f "$helper_path" ]]; then
            local stats_json
            stats_json=$(python3 "$helper_path" "$target_path" 2>/dev/null)
            if [[ -n "$stats_json" ]]; then
                local parsed
                parsed=$(SIZEUP_JSON="$stats_json" python3 - <<'PY'
import json, os
data = json.loads(os.environ.get("SIZEUP_JSON", "{}"))
keys = (
    "file_rounding_bytes",
    "file_round_alloc_bytes",
    "dir_bytes",
    "dir_rounding_bytes",
    "dir_alloc_bytes",
    "special_total",
    "special_alloc_bytes",
)
for key in keys:
    print(f"{key}={data.get(key, 0)}")
for path in data.get("skipped_paths", []):
    print(f"SKIP={path}")
PY
)
                if [[ -n "$parsed" ]]; then
                    while IFS='=' read -r key value; do
                        case "$key" in
                            file_rounding_bytes) file_rounding_bytes="$value" ;;
                            file_round_alloc_bytes) file_round_alloc_bytes="$value" ;;
                            dir_bytes) dir_bytes="$value" ;;
                            dir_rounding_bytes) dir_rounding_bytes="$value" ;;
                            dir_alloc_bytes) dir_alloc_bytes="$value" ;;
                            special_total) special_total="$value" ;;
                            special_alloc_bytes) special_alloc_bytes="$value" ;;
                            SKIP) skipped_paths+=("$value") ;;
                        esac
                    done <<< "$parsed"
                fi
            fi
        elif [[ -f "$target_path" || -L "$target_path" ]]; then
            local file_size=$(file_logical_bytes "$target_path")
            local file_blocks=$(stat_value_or_zero '%b' "$target_path")
            file_rounding_bytes=$(( ((file_size + 511) / 512) * 512 - file_size ))
            file_round_alloc_bytes=$(( file_blocks * DU_BLOCK_SIZE - file_size ))
            (( file_rounding_bytes < 0 )) && file_rounding_bytes=0
            (( file_round_alloc_bytes < 0 )) && file_round_alloc_bytes=0
            if [[ -L "$target_path" ]]; then
                special_total=$file_size
                special_alloc_bytes=$(( file_blocks * DU_BLOCK_SIZE ))
                file_rounding_bytes=0
                file_round_alloc_bytes=0
            fi
        fi

        local du_errors find_errors
        du_errors=$(/usr/bin/du -sA "$target_path" 2>&1 | /usr/bin/grep -i 'denied\|error' || true)
        if [[ -d "$target_path" ]]; then
            find_errors=$( (/usr/bin/find "$target_path" -type f -exec /usr/bin/stat -f %z {} +) 2>&1 | /usr/bin/grep -i 'stat:' || true)
        fi

        # Compute deltas and prepare for table output
        dir_bytes=${dir_bytes:-0}
        dir_rounding_bytes=${dir_rounding_bytes:-0}
        dir_alloc_bytes=${dir_alloc_bytes:-0}
        file_rounding_bytes=${file_rounding_bytes:-0}
        file_round_alloc_bytes=${file_round_alloc_bytes:-0}
        special_total=${special_total:-0}
        special_alloc_bytes=${special_alloc_bytes:-0}

        local hl_savings=$(( stat_sum_nodedup - stat_sum_dedup ))
        local logical_delta=$(( du_app_bytes - stat_sum_dedup ))
        local disk_delta=$(( disk_bytes - stat_sum_dedup ))
        local sum_delta=$(( stat_sum_nodedup - stat_sum_dedup ))

        # Scope diagnostics: symlinks and mount boundaries
        local stat_sum_follow=0
        local du_app_x=""
        if [[ -d "$target_path" ]]; then
            # Sum following symlinks
            stat_sum_follow=$(/usr/bin/find -L "$target_path" -type f -print0 2>/dev/null | \
                while IFS= read -r -d '' file; do
                    /usr/bin/stat -f '%z' "$file" 2>/dev/null || printf '0\n'
                done | /usr/bin/awk '{total+=$1} END {print total+0}')
            # du apparent without crossing filesystems
            if /usr/bin/du -x -sA "$target_path" >/dev/null 2>&1; then
                local du_x_blocks
                du_x_blocks=$(/usr/bin/du -x -sA "$target_path" | /usr/bin/awk '{print $1}')
                du_app_x=$(( du_x_blocks * DU_BLOCK_SIZE ))
            fi
        fi

        # Prepare table values
        dir_bytes=${dir_bytes:-0}
        dir_rounding_bytes=${dir_rounding_bytes:-0}
        dir_alloc_bytes=${dir_alloc_bytes:-0}
        file_rounding_bytes=${file_rounding_bytes:-0}
        file_round_alloc_bytes=${file_round_alloc_bytes:-0}
        special_total=${special_total:-0}
        special_alloc_bytes=${special_alloc_bytes:-0}

        local logical_delta=$(( du_app_bytes - stat_sum_dedup ))
        local disk_delta=$(( disk_bytes - stat_sum_dedup ))
        local sum_delta=$(( stat_sum_nodedup - stat_sum_dedup ))

        local -a component_names
        local -a col_logical
        local -a col_disk
        local -a col_sum
        component_names=(
            "Directory metadata"
            "Directory block rounding"
            "File block rounding"
            "Special items"
            "Hard-link duplicates"
        )
        col_logical=(
            $dir_bytes
            $dir_rounding_bytes
            $file_rounding_bytes
            $special_total
            0
        )
        col_disk=(
            $dir_alloc_bytes
            0
            $file_round_alloc_bytes
            $special_alloc_bytes
            0
        )
        col_sum=(
            0
            0
            0
            0
            $hl_savings
        )

        local logical_explained=0
        local disk_explained=0
        local sum_explained=0
        for val in "${col_logical[@]}"; do (( logical_explained += val )); done
        for val in "${col_disk[@]}"; do (( disk_explained += val )); done
        for val in "${col_sum[@]}"; do (( sum_explained += val )); done

        local logical_remainder=$(( logical_delta - logical_explained ))
        local disk_remainder=$(( disk_delta - disk_explained ))
        local sum_remainder=$(( sum_delta - sum_explained ))

        if (( logical_remainder != 0 )); then
            component_names+=("Unreadable / other")
            col_logical+=("$logical_remainder")
            col_disk+=(0)
            col_sum+=(0)
            logical_explained=$(( logical_explained + logical_remainder ))
            logical_remainder=0
        fi
        if (( disk_remainder != 0 )); then
            component_names+=("Disk remainder")
            col_logical+=(0)
            col_disk+=("$disk_remainder")
            col_sum+=(0)
            disk_explained=$(( disk_explained + disk_remainder ))
            disk_remainder=0
        fi
        if (( sum_remainder != 0 )); then
            component_names+=("Sum remainder")
            col_logical+=(0)
            col_disk+=(0)
            col_sum+=("$sum_remainder")
            sum_explained=$(( sum_explained + sum_remainder ))
            sum_remainder=0
        fi

        echo
        echo "Comparison table (Δ vs unique bytes):"

        local header_component="Component"
        local header_logical="Logical size"
        local header_disk="Size on disk"
        local header_sum="Sum of files"

        local comp_width=${#header_component}
        local logical_width=${#header_logical}
        local disk_width=${#header_disk}
        local sum_width=${#header_sum}

        local -a logical_texts=()
        local -a disk_texts=()
        local -a sum_texts=()
        local -a logical_colors=()
        local -a disk_colors=()
        local -a sum_colors=()

        local components_count=${#component_names[@]}
        for ((idx=1; idx<=components_count; idx++)); do
            local name=${component_names[idx]}
            (( ${#name} > comp_width )) && comp_width=${#name}

            local lres=$(format_cell "${col_logical[idx]:-0}")
            local ltext=${lres%%$'\t'*}
            local lcolor=${lres#*$'\t'}

            local dres=$(format_cell "${col_disk[idx]:-0}")
            local dtext=${dres%%$'\t'*}
            local dcolor=${dres#*$'\t'}

            local sres=$(format_cell "${col_sum[idx]:-0}")
            local stext=${sres%%$'\t'*}
            local scolor=${sres#*$'\t'}

            logical_colors[idx]="$lcolor"
            disk_colors[idx]="$dcolor"
            sum_colors[idx]="$scolor"
            logical_texts[idx]=$ltext
            disk_texts[idx]=$dtext
            sum_texts[idx]=$stext

            (( ${#ltext} > logical_width )) && logical_width=${#ltext}
            (( ${#dtext} > disk_width )) && disk_width=${#dtext}
            (( ${#stext} > sum_width )) && sum_width=${#stext}
        done

        local delta_logical_res=$(format_cell "$logical_delta")
        local delta_logical_text=${delta_logical_res%%$'\t'*}
        local delta_logical_color=${delta_logical_res#*$'\t'}

        local delta_disk_res=$(format_cell "$disk_delta")
        local delta_disk_text=${delta_disk_res%%$'\t'*}
        local delta_disk_color=${delta_disk_res#*$'\t'}

        local delta_sum_res=$(format_cell "$sum_delta")
        local delta_sum_text=${delta_sum_res%%$'\t'*}
        local delta_sum_color=${delta_sum_res#*$'\t'}

        (( ${#delta_logical_text} > logical_width )) && logical_width=${#delta_logical_text}
        (( ${#delta_disk_text} > disk_width )) && disk_width=${#delta_disk_text}
        (( ${#delta_sum_text} > sum_width )) && sum_width=${#delta_sum_text}

        local sep_component=$(repeat_char "-" $comp_width)
        local sep_logical=$(repeat_char "-" $logical_width)
        local sep_disk=$(repeat_char "-" $disk_width)
        local sep_sum=$(repeat_char "-" $sum_width)

        pad_and_color() {
            local text="$1"
            local width="$2"
            local color="$3"
            local pad_width=$(( width - ${#text} ))
            (( pad_width < 0 )) && pad_width=0
            local padding=""
            if (( pad_width > 0 )); then
                padding=$(repeat_char " " "$pad_width")
            fi
            if (( use_color )) && [[ -n "$color" ]]; then
                printf "%s%s%s%s" "$color" "$text" "$color_reset" "$padding"
            else
                printf "%s%s" "$text" "$padding"
            fi
        }

        printf "  %-*s | %-*s | %-*s | %-*s\n" \
            $comp_width "$header_component" \
            $logical_width "$header_logical" \
            $disk_width "$header_disk" \
            $sum_width "$header_sum"

        printf "  %s-+-%s-+-%s-+-%s\n" \
            "$sep_component" "$sep_logical" "$sep_disk" "$sep_sum"

        for ((idx=1; idx<=components_count; idx++)); do
            local logical_cell="$(pad_and_color "${logical_texts[idx]}" $logical_width "${logical_colors[idx]}")"
            local disk_cell="$(pad_and_color "${disk_texts[idx]}" $disk_width "${disk_colors[idx]}")"
            local sum_cell="$(pad_and_color "${sum_texts[idx]}" $sum_width "${sum_colors[idx]}")"
            printf "  %-*s | %s | %s | %s\n" \
                $comp_width "${component_names[idx]}" \
                "$logical_cell" \
                "$disk_cell" \
                "$sum_cell"
        done

        printf "  %s-+-%s-+-%s-+-%s\n" \
            "$sep_component" "$sep_logical" "$sep_disk" "$sep_sum"

        local delta_logical_cell="$(pad_and_color "$delta_logical_text" $logical_width "$delta_logical_color")"
        local delta_disk_cell="$(pad_and_color "$delta_disk_text" $disk_width "$delta_disk_color")"
        local delta_sum_cell="$(pad_and_color "$delta_sum_text" $sum_width "$delta_sum_color")"
        printf "  %-*s | %s | %s | %s\n" \
            $comp_width "Delta vs unique bytes" \
            "$delta_logical_cell" \
            "$delta_disk_cell" \
            "$delta_sum_cell"

        if (( ${#skipped_paths[@]} > 0 )); then
            echo
            echo "Paths counted in logical size but skipped during inspection:"
            for path in "${skipped_paths[@]}"; do
                printf "  %s\n" "$path"
            done
        fi

        # Scope interpretation hints
        if [[ -d "$target_path" ]]; then
            echo
            echo "Scope checks:"
            local follow_delta=$(( stat_sum_follow - stat_sum_dedup ))
            if [[ "$follow_delta" != 0 ]]; then
                printf "  Following symlinks adds: %s (%s bytes)\n" "$(format_bytes "$follow_delta")" "$follow_delta"
            fi
            if [[ -n "$du_app_x" && "$du_app_x" != "$du_app_bytes" ]]; then
                local xdelta=$(( du_app_bytes - du_app_x ))
                printf "  Cross-filesystem content: %s (%s bytes)\n" "$(format_bytes "$xdelta")" "$xdelta"
            fi
            if [[ "$follow_delta" == 0 && ( -z "$du_app_x" || "$du_app_x" == "$du_app_bytes" ) ]]; then
                echo "  No symlink or cross-filesystem scope differences detected."
            fi
        fi

        # Errors
        if [[ -n "$du_errors" || -n "$find_errors" ]]; then
            echo
            echo "Issues encountered:"
            [[ -n "$du_errors" ]] && echo "$du_errors"
            [[ -n "$find_errors" ]] && echo "$find_errors"
        fi

        # Top contributors
        if [[ -d "$target_path" ]]; then
            echo
            echo "Top directories by directory-entry bytes:"
            /usr/bin/find "$target_path" -type d -exec /usr/bin/stat -f '%z %N' {} + 2>/dev/null | /usr/bin/awk '$1>0' | /usr/bin/sort -nr | /usr/bin/head

            # Show top hard-link groups if any savings
            if (( hl_savings > 0 )); then
                echo
                echo "Largest hard-link groups (inode, links, bytes, sample path):"
                /usr/bin/find "$target_path" -type f -links +1 -exec /usr/bin/stat -f '%i %l %z %N' {} + 2>/dev/null | /usr/bin/sort -k1,1 -k3,3nr | /usr/bin/head
            fi
        fi

    fi

}

sizeup "$@"
