sizeup () {
    # Show help message
    show_help() {
        cat << EOF
Usage: sizeup [--sum] [--explain] <path>
Display the logical size and size on disk of a file or directory. When
--sum is provided, also report the logical size by summing individual files.

Options:
    -h, --help    Show this help message
    --sum         Include a logical size calculated by summing file sizes
    --explain     Print diagnostics explaining differences in measurements

The logical size shows the full, uncompressed size of the data stored in the
file or directory. The size on disk shows how much physical disk space is
actually being used, which is typically what you want when investigating disk
space usage. On macOS, this figure is rounded up to 512-byte allocation blocks,
so small files may appear larger on disk than their logical size, and
directories may include metadata overhead. Compression, sparse files, or other
filesystem optimizations can also make the size on disk smaller than the
logical size.

Examples:
    sizeup /path/to/file
    sizeup /path/to/directory
    sizeup --sum /path/to/directory
EOF
    }

    if [[ $# -eq 0 ]]; then
        show_help
        return 1
    fi

    local sum_flag=0
    local explain_flag=0
    local target_path=""
    local humanize_available=0
    local -r DU_BLOCK_SIZE=512

    if command -v humanize_bytes >/dev/null 2>&1; then
        humanize_available=1
    fi

    local use_color=0
    local color_reset=""
    local color_pos=""
    local color_neg=""
    local color_neutral=""
    if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
        local tput_colors
        tput_colors=$(tput colors 2>/dev/null || printf '0')
        if (( tput_colors >= 8 )); then
            use_color=1
            color_reset=$'\e[0m'
            color_pos=$'\e[32m'
            color_neg=$'\e[31m'
            color_neutral=$'\e[36m'
        fi
    fi

    format_size_line() {
        local label="$1"
        local bytes="$2"
        local human=""

        if [[ -z "$bytes" ]]; then
            bytes=0
        fi

        if (( humanize_available )); then
            human=$(humanize_bytes "$bytes" 2>/dev/null)
        fi

        if [[ -z "$human" ]]; then
            human="${bytes}B"
        fi

        printf "%-28s %s (%s)\n" "${label}:" "$human" "$bytes"
    }

    colorize() {
        local text="$1"
        local color="$2"
        if (( use_color )) && [[ -n "$color" ]]; then
            printf "%s%s%s" "$color" "$text" "$color_reset"
        else
            printf "%s" "$text"
        fi
    }

    format_bytes() {
        local value="$1"
        local human=""
        if (( humanize_available )); then
            human=$(humanize_bytes "$value" 2>/dev/null)
        fi
        if [[ -z "$human" ]]; then
            human="${value}B"
        fi
        printf "%s" "$human"
    }

    repeat_char() {
        local char="$1"
        local count="$2"
        if (( count <= 0 )); then
            return
        fi
        printf "%${count}s" "" | tr ' ' "$char"
    }

    stat_value_or_zero() {
        local format="$1"
        local path="$2"
        /usr/bin/stat -f "$format" "$path" 2>/dev/null || printf '0\n'
    }

    file_logical_bytes() {
        stat_value_or_zero '%z' "$1"
    }

    file_disk_bytes() {
        local blocks
        blocks=$(stat_value_or_zero '%b' "$1")
        printf '%s\n' "$(( blocks * DU_BLOCK_SIZE ))"
    }

    disk_bytes_for_path() {
        local path="$1"

        if [[ -f "$path" || -L "$path" ]]; then
            file_disk_bytes "$path"
            return
        fi

        local blocks
        blocks=$(/usr/bin/du -s "$path" 2>/dev/null | /usr/bin/awk '{print $1}')

        if [[ -n "$blocks" ]]; then
            printf '%s\n' "$(( blocks * DU_BLOCK_SIZE ))"
        else
            printf '0\n'
        fi
    }

    logical_bytes_for_path() {
        local path="$1"

        if [[ -f "$path" || -L "$path" ]]; then
            file_logical_bytes "$path"
            return
        fi

        local blocks
        blocks=$(/usr/bin/du -s -A "$path" 2>/dev/null | /usr/bin/awk '{print $1}')

        if [[ -n "$blocks" ]]; then
            printf '%s\n' "$(( blocks * DU_BLOCK_SIZE ))"
        else
            printf '0\n'
        fi
    }

    sum_bytes_for_path() {
        local path="$1"
        local bytes=""

        if [[ -f "$path" || -L "$path" ]]; then
            file_logical_bytes "$path"
            return
        fi

        bytes=$(/usr/bin/find "$path" -type f -print0 2>/dev/null | \
            while IFS= read -r -d '' file; do
                /usr/bin/stat -f '%z' "$file" 2>/dev/null || printf '0\n'
            done | /usr/bin/awk '{total+=$1} END {print total+0}')

        printf '%s\n' "${bytes:-0}"
    }

    dedup_bytes_for_path() {
        local path="$1"

        if [[ -f "$path" || -L "$path" ]]; then
            file_logical_bytes "$path"
            return
        fi

        /usr/bin/find "$path" -type f -print0 2>/dev/null | \
            while IFS= read -r -d '' file; do
                /usr/bin/stat -f '%i %z' "$file" 2>/dev/null || printf '0 0\n'
            done | /usr/bin/awk '{if(!seen[$1]++) sum+=$2} END {print sum+0}'
    }

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                return 0
                ;;
            --sum)
                sum_flag=1
                shift
                ;;
            --explain)
                explain_flag=1
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "Error: unknown option '$1'"
                return 1
                ;;
            *)
                target_path="$1"
                shift
                break
                ;;
        esac
    done

    if [[ -z "$target_path" ]] && [[ $# -gt 0 ]]; then
        target_path="$1"
        shift
    fi

    if [[ -z "$target_path" ]]; then
        echo "Error: missing path argument"
        return 1
    fi

    if [[ $# -gt 0 ]]; then
        echo "Error: unexpected argument '$1'"
        return 1
    fi

    # Check if the path exists
    if [[ ! -e "$target_path" ]]; then
        echo "Error: '$target_path' does not exist"
        return 1
    fi

    # Prepare sum placeholders
    local sum_bytes=""
    local sum_dedup_bytes=""

    # Get size on disk (actual allocated space, rounded to 512-byte blocks)
    local disk_bytes
    disk_bytes=$(disk_bytes_for_path "$target_path")
    format_size_line "Size on disk" "$disk_bytes"

    # Get logical size (apparent size of data)
    local logical_bytes
    logical_bytes=$(logical_bytes_for_path "$target_path")
    format_size_line "Logical size" "$logical_bytes"

    if (( sum_flag )); then
        sum_bytes=$(sum_bytes_for_path "$target_path")
        format_size_line "Logical size (sum of files)" "$sum_bytes"

        sum_dedup_bytes=$(dedup_bytes_for_path "$target_path")
        if [[ -n "$sum_dedup_bytes" && "$sum_dedup_bytes" != "$sum_bytes" ]]; then
            format_size_line "Unique file bytes (dedup)" "$sum_dedup_bytes"
        fi
    fi

    if (( explain_flag )); then
        echo
        echo "Explain Differences"
        # Baselines (re-use logical_bytes to avoid conversion drift)
        local du_app_bytes="$logical_bytes"
        local stat_sum_nodedup=""
        local stat_sum_dedup=""
        if [[ -n "$sum_bytes" ]]; then
            stat_sum_nodedup="$sum_bytes"
        elif [[ -d "$target_path" ]]; then
            stat_sum_nodedup=$(sum_bytes_for_path "$target_path")
        else
            stat_sum_nodedup=$(file_logical_bytes "$target_path")
        fi

        if [[ -n "$sum_dedup_bytes" ]]; then
            stat_sum_dedup="$sum_dedup_bytes"
        elif [[ -d "$target_path" ]]; then
            stat_sum_dedup=$(dedup_bytes_for_path "$target_path")
        else
            stat_sum_dedup=$(file_logical_bytes "$target_path")
        fi

        local dir_bytes=0
        local symlink_bytes=0 socket_bytes=0 char_bytes=0 block_bytes=0 other_bytes=0
        local file_rounding_bytes=0
        local dir_rounding_bytes=0
        if [[ -d "$target_path" ]]; then
            dir_bytes=$(/usr/bin/find "$target_path" -type d -print0 2>/dev/null | \
                while IFS= read -r -d '' d; do
                    /usr/bin/stat -f '%z' "$d" 2>/dev/null || printf '0\n'
                done | /usr/bin/awk '{total+=$1} END {print total+0}')

            symlink_bytes=$(/usr/bin/find "$target_path" -type l -print0 2>/dev/null | \
                while IFS= read -r -d '' link; do
                    /usr/bin/stat -f '%z' "$link" 2>/dev/null || printf '0\n'
                done | /usr/bin/awk '{total+=$1} END {print total+0}')

            socket_bytes=$(/usr/bin/find "$target_path" -type s -print0 2>/dev/null | \
                while IFS= read -r -d '' sock; do
                    /usr/bin/stat -f '%z' "$sock" 2>/dev/null || printf '0\n'
                done | /usr/bin/awk '{total+=$1} END {print total+0}')

            char_bytes=$(/usr/bin/find "$target_path" -type c -print0 2>/dev/null | \
                while IFS= read -r -d '' dev; do
                    /usr/bin/stat -f '%z' "$dev" 2>/dev/null || printf '0\n'
                done | /usr/bin/awk '{total+=$1} END {print total+0}')

            block_bytes=$(/usr/bin/find "$target_path" -type b -print0 2>/dev/null | \
                while IFS= read -r -d '' dev; do
                    /usr/bin/stat -f '%z' "$dev" 2>/dev/null || printf '0\n'
                done | /usr/bin/awk '{total+=$1} END {print total+0}')

            other_bytes=$(/usr/bin/find "$target_path" ! -type f ! -type d ! -type l ! -type s ! -type c ! -type b -print0 2>/dev/null | \
                while IFS= read -r -d '' item; do
                    /usr/bin/stat -f '%z' "$item" 2>/dev/null || printf '0\n'
                done | /usr/bin/awk '{total+=$1} END {print total+0}')

            if command -v python3 >/dev/null 2>&1; then
                local rounding_output
                rounding_output=$(TARGET_PATH="$target_path" python3 - <<'PY'
import os, math

root = os.environ.get("TARGET_PATH")
if not root:
    print(0, 0)
    raise SystemExit
file_round = 0
dir_round = 0
seen = set()

for dirpath, dirnames, filenames in os.walk(root, followlinks=False, onerror=lambda e: None):
    try:
        st_dir = os.lstat(dirpath)
    except (FileNotFoundError, PermissionError):
        continue
    dir_round += ((st_dir.st_size + 511) // 512) * 512 - st_dir.st_size
    for name in filenames:
        path = os.path.join(dirpath, name)
        try:
            st = os.lstat(path)
        except (FileNotFoundError, PermissionError):
            continue
        key = (st.st_dev, st.st_ino)
        if key in seen:
            continue
        seen.add(key)
        file_round += ((st.st_size + 511) // 512) * 512 - st.st_size

print(file_round, dir_round)
PY
)
                if [[ -n "$rounding_output" ]]; then
                    read -r file_rounding_bytes dir_rounding_bytes <<< "$rounding_output"
                fi
            fi
        fi

        local du_errors find_errors
        du_errors=$(/usr/bin/du -sA "$target_path" 2>&1 | /usr/bin/grep -i 'denied\|error' || true)
        if [[ -d "$target_path" ]]; then
            find_errors=$( (/usr/bin/find "$target_path" -type f -exec /usr/bin/stat -f %z {} +) 2>&1 | /usr/bin/grep -i 'stat:' || true)
        fi

        # Compute deltas and bucketization
        local bridge_total=$(( du_app_bytes - stat_sum_dedup ))
        local delta=$(( stat_sum_dedup - du_app_bytes ))
        local hl_savings=$(( stat_sum_nodedup - stat_sum_dedup ))
        local special_total=$(( symlink_bytes + socket_bytes + char_bytes + block_bytes + other_bytes ))

        local dir_contrib=$dir_bytes
        local special_contrib=$special_total
        local file_round_contrib=$file_rounding_bytes
        local dir_round_contrib=$dir_rounding_bytes

        # Helper to print bucket line with percent of delta
        _print_bucket() {
            local label="$1"; local bytes="$2"
            local base_abs=${bridge_total#-}
            local pct="0.0"
            if (( base_abs != 0 )); then
                pct=$(/usr/bin/awk -v b="$bytes" -v base="$base_abs" 'BEGIN{printf("%.1f", base==0?0:(b*100.0)/base)}')
            fi
            local abs_bytes="$bytes"
            local sign=""
            local color=""
            if [[ "$bytes" == -* ]]; then
                sign="-"
                abs_bytes=${bytes#-}
                color=$color_neg
            elif [[ "$bytes" == "0" ]]; then
                abs_bytes=0
                sign=" "
                color=$color_neutral
            else
                sign="+"
                color=$color_pos
            fi
            local human_bytes
            if (( humanize_available )); then
                human_bytes=$(humanize_bytes "$abs_bytes" 2>/dev/null)
            fi
            if [[ -z "$human_bytes" ]]; then
                human_bytes="${abs_bytes}B"
            fi
            local display="${sign}${human_bytes}"
            if [[ "$sign" == " " ]]; then
                display="0B"
            fi
            if (( use_color )) && [[ "$sign" != " " ]]; then
                display=$(colorize "$display" "$color")
            fi
            printf "  %-24s %12s (%s bytes)  %6s%%\n" "$label:" "$display" "$bytes" "$pct"
        }

        # Summary line
        local delta_abs="$delta"
        if [[ "$delta" == -* ]]; then
            delta_abs=${delta#-}
        fi
        local delta_human
        if command -v humanize_bytes >/dev/null 2>&1; then
            delta_human=$(humanize_bytes "$delta_abs" 2>/dev/null)
        else
            delta_human="${delta_abs}B"
        fi
        if (( delta > 0 )); then
            echo "Summary: Unique file bytes (dedup) are +${delta_human} ($delta bytes) vs logical size."
        elif (( delta < 0 )); then
            echo "Summary: Unique file bytes (dedup) are -${delta_human} ($delta bytes) vs logical size."
        else
            echo "Summary: Unique file bytes (dedup) match logical size."
        fi

        local raw_delta=$(( stat_sum_nodedup - du_app_bytes ))
        if (( raw_delta != delta )); then
            local raw_abs="$raw_delta"
            if [[ "$raw_delta" == -* ]]; then
                raw_abs=${raw_delta#-}
            fi
            local raw_human
            if command -v humanize_bytes >/dev/null 2>&1; then
                raw_human=$(humanize_bytes "$raw_abs" 2>/dev/null)
            else
                raw_human="${raw_abs}B"
            fi
            if (( raw_delta > 0 )); then
                echo "  Including duplicate hard links, sum of file entries is +${raw_human} ($raw_delta bytes) vs logical size."
            elif (( raw_delta < 0 )); then
                echo "  Including duplicate hard links, sum of file entries is -${raw_human} ($raw_delta bytes) vs logical size."
            fi
        fi

        echo
        echo "Breakdown (unique vs logical):"
        _print_bucket "Missing directory metadata" "$dir_contrib"
        _print_bucket "512B rounding (files)" "$file_round_contrib"
        _print_bucket "512B rounding (directories)" "$dir_round_contrib"
        _print_bucket "Missing special items" "$special_contrib"

        # Scope diagnostics: symlinks and mount boundaries
        local stat_sum_follow=0
        local du_app_x=""
        if [[ -d "$target_path" ]]; then
            # Sum following symlinks
            stat_sum_follow=$(/usr/bin/find -L "$target_path" -type f -print0 2>/dev/null | \
                while IFS= read -r -d '' file; do
                    /usr/bin/stat -f '%z' "$file" 2>/dev/null || printf '0\n'
                done | /usr/bin/awk '{total+=$1} END {print total+0}')
            # du apparent without crossing filesystems
            if /usr/bin/du -x -sA "$target_path" >/dev/null 2>&1; then
                local du_x_blocks
                du_x_blocks=$(/usr/bin/du -x -sA "$target_path" | /usr/bin/awk '{print $1}')
                du_app_x=$(( du_x_blocks * DU_BLOCK_SIZE ))
            fi
        fi

        # Remainder bucket
        local explained=$(( dir_contrib + file_round_contrib + dir_round_contrib + special_contrib ))
        local remainder=$(( bridge_total - explained ))
        _print_bucket "Remaining difference" "$remainder"

        local -a contrib_labels
        local -a contrib_values
        local -a contrib_chars
        contrib_labels=(
            "Directory metadata"
            "512B rounding (files)"
            "512B rounding (directories)"
            "Special items"
        )
        contrib_values=(
            "$dir_contrib"
            "$file_round_contrib"
            "$dir_round_contrib"
            "$special_contrib"
        )
        contrib_chars=( M F R S )
        if [[ "$remainder" != 0 ]]; then
            contrib_labels+=("Unexplained remainder")
            contrib_values+=("$remainder")
            contrib_chars+=("?")
        fi

        if (( hl_savings != 0 )); then
            local hl_human="$hl_savings"
            if command -v humanize_bytes >/dev/null 2>&1; then
                hl_human=$(humanize_bytes "$hl_savings" 2>/dev/null)
            fi
            local hl_display="+$hl_human"
            if (( use_color )); then
                hl_display=$(colorize "$hl_display" "$color_pos")
            fi
            echo
            echo "Hard-link duplicates removed when deduping: $hl_display ($hl_savings bytes)"
        fi

        echo
        echo "Visualization (unique → logical):"
        local term_cols=${COLUMNS:-$(tput cols 2>/dev/null || echo 80)}
        local bar_width=42
        if (( term_cols > 100 )); then
            bar_width=$(( term_cols - 58 ))
        fi
        (( bar_width < 30 )) && bar_width=30

        local max_value=$du_app_bytes
        if (( stat_sum_dedup > max_value )); then
            max_value=$stat_sum_dedup
        fi
        (( max_value == 0 )) && max_value=1

        local unique_len=$(( stat_sum_dedup * bar_width / max_value ))
        local logical_len=$(( du_app_bytes * bar_width / max_value ))
        if (( stat_sum_dedup > 0 && unique_len == 0 )); then unique_len=1; fi
        if (( du_app_bytes > 0 && logical_len == 0 )); then logical_len=1; fi
        (( unique_len > bar_width )) && unique_len=$bar_width
        (( logical_len > bar_width )) && logical_len=$bar_width

        local max_len=$unique_len
        (( logical_len > max_len )) && max_len=$logical_len
        local min_len=$unique_len
        (( logical_len < min_len )) && min_len=$logical_len

        local diff_abs=${bridge_total#-}
        local diff_len=$(( max_len - min_len ))
        local common_len=$min_len
        local chart_unique=""
        local chart_logical=""
        local diff_bar=""
        local diff_sign=1
        (( bridge_total < 0 )) && diff_sign=-1

        local build_diff_bar() {
            local length="$1"
            local total_abs="$2"
            local sign_required="$3"
            local remaining="$length"
            local result=""
            local last_char="."
            local idx=1
            local count=${#contrib_labels[@]}
            while (( idx <= count )) && (( remaining > 0 )); do
                local value=${contrib_values[idx]}
                local char=${contrib_chars[idx]}
                if [[ -z "$value" || -z "$char" ]]; then
                    (( idx++ ))
                    continue
                fi
                local val_sign=1
                local abs_val=$value
                if (( value < 0 )); then
                    val_sign=-1
                    abs_val=${value#-}
                fi
                if (( abs_val == 0 || val_sign != sign_required )); then
                    (( idx++ ))
                    continue
                fi
                local chars=$(( abs_val * length / total_abs ))
                if (( chars == 0 )); then chars=1; fi
                if (( chars > remaining )); then chars=$remaining; fi
                result+=$(repeat_char "$char" "$chars")
                remaining=$(( remaining - chars ))
                last_char="$char"
                (( idx++ ))
            done
            if (( remaining > 0 )); then
                result+=$(repeat_char "$last_char" "$remaining")
            fi
            printf "%s" "$result"
        }

        if (( diff_abs > 0 && diff_len > 0 )); then
            diff_bar=$(build_diff_bar "$diff_len" "$diff_abs" "$diff_sign")
        fi

        local diff_lower=$(printf "%s" "$diff_bar" | tr 'A-Z' 'a-z')

        if (( bridge_total >= 0 )); then
            chart_unique="$(repeat_char "#" "$common_len")${diff_lower}"
            chart_logical="$(repeat_char "#" "$common_len")${diff_bar}"
        else
            chart_unique="$(repeat_char "#" "$common_len")${diff_bar}"
            chart_logical="$(repeat_char "#" "$common_len")${diff_lower}"
        fi

        local pad_unique=$(( bar_width - max_len ))
        (( pad_unique < 0 )) && pad_unique=0
        local pad_logical=$pad_unique
        chart_unique+=$(repeat_char " " "$pad_unique")
        chart_logical+=$(repeat_char " " "$pad_logical")

        printf "  %-24s |%s| %s (%s)\n" "$(colorize 'Unique bytes' "$color_neutral")" "$chart_unique" "$(format_bytes "$stat_sum_dedup")" "$stat_sum_dedup"
        printf "  %-24s |%s| %s (%s)\n" "$(colorize 'Logical size' "$color_pos")" "$chart_logical" "$(format_bytes "$du_app_bytes")" "$du_app_bytes"

        if (( diff_abs > 0 && diff_len > 0 )); then
            echo
            echo "  Difference components:"
            local idx=1
            local total_items=${#contrib_labels[@]}
            while (( idx <= total_items )); do
                local label=${contrib_labels[idx]}
                local value=${contrib_values[idx]}
                local char=${contrib_chars[idx]}
                if [[ -z "$value" || -z "$char" ]]; then
                    (( idx++ ))
                    continue
                fi
                local val_sign=1
                local abs_value=$value
                if (( value < 0 )); then
                    val_sign=-1
                    abs_value=${value#-}
                fi
                if (( abs_value == 0 || val_sign != diff_sign )); then
                    (( idx++ ))
                    continue
                fi
                local percent=$(/usr/bin/awk -v b="$abs_value" -v total="$diff_abs" 'BEGIN{printf("%.1f", total==0?0:(b*100.0)/total)}')
                local formatted=$(format_bytes "$abs_value")
                local bar_len=$(( abs_value * bar_width / diff_abs ))
                (( bar_len == 0 )) && bar_len=1
                (( bar_len > bar_width )) && bar_len=$bar_width
                local bar=$(repeat_char "$char" "$bar_len")
                local tail=$(repeat_char " " $(( bar_width - bar_len )))
                if (( use_color )); then
                    local seg_color=$color_pos
                    (( diff_sign < 0 )) && seg_color=$color_neg
                    bar=$(colorize "$bar" "$seg_color")
                fi
                local sign_char="+"
                (( diff_sign < 0 )) && sign_char="-"
                printf "    [%s] %-18s |%s%s| %s%s (%s bytes, %s%%)\n" "$char" "$label" "$bar" "$tail" "$sign_char" "$formatted" "$abs_value" "$percent"
                (( idx++ ))
            done
            echo
            echo "    Legend: # shared bytes, M directory metadata, F file rounding, R directory rounding, S special items, ? remainder"
            echo "            Uppercase letters mark where a component is counted; lowercase shows it is missing from that total."
        fi

        echo
        echo "  Step-by-step (accumulating to logical):"
        local current=$stat_sum_dedup
        printf "    %-30s %12s (%s)\n" "Start: Unique" "$(format_bytes "$current")" "$current"
        local idx_step=1
        local total_step=${#contrib_labels[@]}
        while (( idx_step <= total_step )); do
            local step_label=${contrib_labels[idx_step]}
            local step_value=${contrib_values[idx_step]}
            if [[ -z "$step_value" ]]; then
                step_value=0
            fi
            if (( step_value != 0 )); then
                current=$(( current + step_value ))
                local step_sign="+"
                local abs_step=$step_value
                if (( step_value < 0 )); then
                    step_sign="-"
                    abs_step=${step_value#-}
                fi
                printf "    %s %-28s %12s (%s)\n" "$step_sign" "$step_label" "$(format_bytes "$current")" "$current"
            fi
            (( idx_step++ ))
        done
        printf "    %-30s %12s (%s)\n" "Result: Logical" "$(format_bytes "$du_app_bytes")" "$du_app_bytes"

        # Scope interpretation hints
        if [[ -d "$target_path" ]]; then
            echo
            echo "Scope checks:"
            local follow_delta=$(( stat_sum_follow - stat_sum_dedup ))
            if [[ "$follow_delta" != 0 ]]; then
                _print_bucket "Following symlinks adds" "$follow_delta"
            fi
            if [[ -n "$du_app_x" && "$du_app_x" != "$du_app_bytes" ]]; then
                local xdelta=$(( du_app_bytes - du_app_x ))
                _print_bucket "Cross-filesystem content" "$xdelta"
            fi
            if [[ "$follow_delta" == 0 && ( -z "$du_app_x" || "$du_app_x" == "$du_app_bytes" ) ]]; then
                echo "  No symlink or cross-filesystem scope differences detected."
            fi
        fi

        # Errors
        if [[ -n "$du_errors" || -n "$find_errors" ]]; then
            echo
            echo "Issues encountered:"
            [[ -n "$du_errors" ]] && echo "$du_errors"
            [[ -n "$find_errors" ]] && echo "$find_errors"
        fi

        # Top contributors
        if [[ -d "$target_path" ]]; then
            echo
            echo "Top directories by directory-entry bytes:"
            /usr/bin/find "$target_path" -type d -exec /usr/bin/stat -f '%z %N' {} + 2>/dev/null | /usr/bin/awk '$1>0' | /usr/bin/sort -nr | /usr/bin/head

            # Show top hard-link groups if any savings
            if (( hl_savings > 0 )); then
                echo
                echo "Largest hard-link groups (inode, links, bytes, sample path):"
                /usr/bin/find "$target_path" -type f -links +1 -exec /usr/bin/stat -f '%i %l %z %N' {} + 2>/dev/null | /usr/bin/sort -k1,1 -k3,3nr | /usr/bin/head
            fi
        fi

        # Glossary
        echo
        echo "Glossary:"
        echo "  Logical size: what the system reports for the folder’s content."
        echo "  Sum of file sizes: add up bytes of regular files only."
        echo "  Directory metadata: the folders themselves occupy bytes (entries)."
        echo "  Hard links: multiple names pointing to the same data."
    fi

}

sizeup "$@"
