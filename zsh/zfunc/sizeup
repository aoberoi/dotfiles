sizeup () {
    # Show help message
    show_help() {
        cat << EOF
Usage: sizeup [--sum] <path>
Display the logical size and size on disk of a file or directory. When
--sum is provided, also report the logical size by summing individual files.

Options:
    -h, --help    Show this help message
    --sum         Include a logical size calculated by summing file sizes

The logical size shows the full, uncompressed size of the data stored in the
file or directory. The size on disk shows how much physical disk space is
actually being used, which is typically what you want when investigating disk
space usage. On macOS, this figure is rounded up to 512-byte allocation blocks,
so small files may appear larger on disk than their logical size, and
directories may include metadata overhead. Compression, sparse files, or other
filesystem optimizations can also make the size on disk smaller than the
logical size.

Examples:
    sizeup /path/to/file
    sizeup /path/to/directory
    sizeup --sum /path/to/directory
EOF
    }

    if [[ $# -eq 0 ]]; then
        show_help
        return 1
    fi

    local sum_flag=0
    local target_path=""
    local humanize_available=0
    local -r DU_BLOCK_SIZE=512

    if command -v humanize_bytes >/dev/null 2>&1; then
        humanize_available=1
    fi

    format_size_line() {
        local label="$1"
        local bytes="$2"
        local human=""

        if [[ -z "$bytes" ]]; then
            bytes=0
        fi

        if (( humanize_available )); then
            human=$(humanize_bytes "$bytes" 2>/dev/null)
        fi

        if [[ -z "$human" ]]; then
            human="${bytes}B"
        fi

        printf "%-28s %s (%s)\n" "${label}:" "$human" "$bytes"
    }

    stat_value_or_zero() {
        local format="$1"
        local path="$2"
        /usr/bin/stat -f "$format" "$path" 2>/dev/null || printf '0\n'
    }

    file_logical_bytes() {
        stat_value_or_zero '%z' "$1"
    }

    file_disk_bytes() {
        local blocks
        blocks=$(stat_value_or_zero '%b' "$1")
        printf '%s\n' "$(( blocks * DU_BLOCK_SIZE ))"
    }

    disk_bytes_for_path() {
        local path="$1"

        if [[ -f "$path" || -L "$path" ]]; then
            file_disk_bytes "$path"
            return
        fi

        local blocks
        blocks=$(/usr/bin/du -s "$path" 2>/dev/null | /usr/bin/awk '{print $1}')

        if [[ -n "$blocks" ]]; then
            printf '%s\n' "$(( blocks * DU_BLOCK_SIZE ))"
        else
            printf '0\n'
        fi
    }

    logical_bytes_for_path() {
        local path="$1"

        if [[ -f "$path" || -L "$path" ]]; then
            file_logical_bytes "$path"
            return
        fi

        local blocks
        blocks=$(/usr/bin/du -s -A "$path" 2>/dev/null | /usr/bin/awk '{print $1}')

        if [[ -n "$blocks" ]]; then
            printf '%s\n' "$(( blocks * DU_BLOCK_SIZE ))"
        else
            printf '0\n'
        fi
    }

    sum_bytes_for_path() {
        local path="$1"
        local bytes=""

        if [[ -f "$path" || -L "$path" ]]; then
            file_logical_bytes "$path"
            return
        fi

        bytes=$(/usr/bin/find "$path" -type f -print0 2>/dev/null | \
            while IFS= read -r -d '' file; do
                /usr/bin/stat -f '%z' "$file" 2>/dev/null || printf '0\n'
            done | /usr/bin/awk '{total+=$1} END {print total+0}')

        printf '%s\n' "${bytes:-0}"
    }

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                return 0
                ;;
            --sum)
                sum_flag=1
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "Error: unknown option '$1'"
                return 1
                ;;
            *)
                target_path="$1"
                shift
                break
                ;;
        esac
    done

    if [[ -z "$target_path" ]] && [[ $# -gt 0 ]]; then
        target_path="$1"
        shift
    fi

    if [[ -z "$target_path" ]]; then
        echo "Error: missing path argument"
        return 1
    fi

    if [[ $# -gt 0 ]]; then
        echo "Error: unexpected argument '$1'"
        return 1
    fi

    # Check if the path exists
    if [[ ! -e "$target_path" ]]; then
        echo "Error: '$target_path' does not exist"
        return 1
    fi

    # Get size on disk (actual allocated space, rounded to 512-byte blocks)
    local disk_bytes
    disk_bytes=$(disk_bytes_for_path "$target_path")
    format_size_line "Size on disk" "$disk_bytes"

    # Get logical size (apparent size of data)
    local logical_bytes
    logical_bytes=$(logical_bytes_for_path "$target_path")
    format_size_line "Logical size" "$logical_bytes"

    if (( sum_flag )); then
        local sum_bytes
        sum_bytes=$(sum_bytes_for_path "$target_path")
        format_size_line "Logical size (sum of files)" "$sum_bytes"
    fi

}

sizeup "$@"
